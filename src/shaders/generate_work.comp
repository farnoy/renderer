#version 450

#extension GL_KHR_shader_subgroup_basic: require
#extension GL_KHR_shader_subgroup_ballot: require
#extension GL_EXT_scalar_block_layout: require
#extension GL_KHR_shader_subgroup_vote : require

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(push_constant, scalar) uniform PushConstants {
    uint gltfIndex;
    uint indexCount;
    uint indexOffset;
    uint indexOffsetInOutput;
    int vertexOffset;
};

layout(set = 0, binding = 0, scalar) uniform ModelMatrices {
    mat4 model[4096];
};

layout(set = 1, binding = 0, scalar) uniform CameraMatrices {
    mat4 projection;
    mat4 view;
    vec4 position;
    mat4 pv;
};

layout(set = 2, binding = 0, scalar) buffer IndirectCommands {
    VkDrawIndexedIndirectCommand indirect_commands[2400];
};

layout(set = 2, binding = 1, scalar) buffer OutIndexBuffer {
    uvec3 out_index_buffer[20000000];
};

layout(set = 2, binding = 2, scalar) buffer readonly VertexBuffer {
    vec3 vertex_buffer[300000];
};

layout(set = 2, binding = 3, scalar) buffer readonly IndexBuffer {
    uvec3 index_buffer[300000];
};

#ifdef RGA
// RGA generates a scalar wavefront without it
layout (local_size_x = 999) in;
#endif
layout (local_size_x_id = 1) in;

shared uint localOffset;
shared uint globalOffset;

void main() {
    if (gl_GlobalInvocationID.x == 0) {
        // indexCount is preinitialized to 0 before a barrier, here would be too late
        indirect_commands[gltfIndex].instanceCount = 1;
        indirect_commands[gltfIndex].firstInstance = gltfIndex;
        indirect_commands[gltfIndex].firstIndex = indexOffsetInOutput;
        indirect_commands[gltfIndex].vertexOffset = vertexOffset;
    }
    if (gl_LocalInvocationID.x == 0) {
        localOffset = 0;
    }
    barrier();

    bool cull = false;

    if (gl_GlobalInvocationID.x < indexCount / 3) {
        uvec3 ix = index_buffer[indexOffset / 3 + gl_GlobalInvocationID.x];
        vec4 input0 = vec4(vertex_buffer[vertexOffset + ix.x], 1.0);
        vec4 input1 = vec4(vertex_buffer[vertexOffset + ix.y], 1.0);
        vec4 input2 = vec4(vertex_buffer[vertexOffset + ix.z], 1.0);
        mat4 mvp = pv * model[gltfIndex];
        vec4 vertex0 = mvp * input0;
        vec4 vertex1 = mvp * input1;
        vec4 vertex2 = mvp * input2;

        // backface culling in counter clockwise front-facing order, left handed projection
        cull = determinant(mat3(vertex0.xyw, vertex1.xyw, vertex2.xyw)) > 0;

        vec3 ndc0 = vertex0.xyz / vertex0.w;
        vec3 ndc1 = vertex1.xyz / vertex1.w;
        vec3 ndc2 = vertex2.xyz / vertex2.w;

        if (!cull)
            cull =
                // frustum culling
                (ndc0.x < -1.0 && ndc1.x < -1.0 && ndc2.x < -1.0) ||
                (ndc0.x > 1.0 && ndc1.x > 1.0 && ndc2.x > 1.0) ||
                (ndc0.y < -1.0 && ndc1.y < -1.0 && ndc2.y < -1.0) ||
                (ndc0.y > 1.0 && ndc1.y > 1.0 && ndc2.y > 1.0);

        // degenerate triangle culling, this is a bad algorithm but even while being
        // conservative here, it discards a lot of stuff
        if (!cull) {
            float a = distance(ndc0, ndc1);
            float b = distance(ndc0, ndc2);
            float c = distance(ndc1, ndc2);
            float s = (a + b + c) / 2.0;
            float area = sqrt(s * (s - a) * (s - b) * (s - c));
            cull = area < 0.0000005; // magic constant
            cull = false; // disable for now
        }

        // live reloading playground - reject triangles after a certain number of them per mesh
        // cull = cull || (gl_GlobalInvocationID.x > 10000);

        uvec4 ballot = subgroupBallot(!cull);
        uint count = subgroupBallotBitCount(ballot);
        uint exclusiveBitCount = subgroupBallotExclusiveBitCount(ballot);

        uint offset = 0;
        if (subgroupElect()) {
            offset = atomicAdd(localOffset, count);
        }
        offset = subgroupBroadcastFirst(offset);

        barrier();

        if (gl_LocalInvocationID.x == 0) {
            globalOffset = atomicAdd(indirect_commands[gltfIndex].indexCount, localOffset * 3);
            globalOffset += indexOffsetInOutput; // to resume where previous mesh ended
            globalOffset /= 3;
        }

        barrier();

        if (!cull) {
            uint local_offset = globalOffset + offset + exclusiveBitCount;
            out_index_buffer[local_offset] = ix;
        }
    }
}
